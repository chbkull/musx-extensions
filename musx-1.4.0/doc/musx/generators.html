<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>musx.generators API documentation</title>
<meta name="description" content="A collection of python generators that produce many different patterns in data,
from simple looping and randomness to more complex processes such as â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>musx.generators</code></h1>
</header>
<section id="section-intro">
<p>A collection of python generators that produce many different patterns in data,
from simple looping and randomness to more complex processes such as markov
chains, cellular automata and chaos.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="musx.generators.allrotations"><code class="name flex">
<span>def <span class="ident">allrotations</span></span>(<span>items, rules, groups=False, repeatfirst=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function returns a list of all the rotations of items until the first
rotation occurs again.
Warning: this function will run until the original
generation returns; rules that do not produce the original generation again
will trigger an infinite loop. See: <code><a title="musx.generators.rotation" href="#musx.generators.rotation">rotation()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>items</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of items to rotate.</dd>
<dt><strong><code>rules</code></strong> :&ensp;<code>rule | list</code></dt>
<dd>A rule, list or generator of rules. See: <code><a title="musx.generators.rotation" href="#musx.generators.rotation">rotation()</a></code>.</dd>
<dt><strong><code>groups</code></strong> :&ensp;<code>bool</code></dt>
<dd>If groups is True then each generation is collected in a sublist,
otherwise the rotated items are returned in one flat list.</dd>
<dt><strong><code>repeatfirst</code></strong> :&ensp;<code>bool</code></dt>
<dd>If repeatfirst is True then the first generation will also be appended
to the end of list returned.</dd>
</dl></div>
</dd>
<dt id="musx.generators.choose"><code class="name flex">
<span>def <span class="ident">choose</span></span>(<span>items, weights=[], stop=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A generator that returns its items using weighted random selection.
By default all items have an equal probability of being returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>items</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of values to generate.</dd>
<dt><strong><code>weights</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of probablity weights for selecting the corresponding items.
Weights do not have to sum to 1 as the generator automatically
converts them to probabilities. If no weights are provided then
items are chosen with equal probability.</dd>
<dt><strong><code>stop</code></strong> :&ensp;<code>int | None</code></dt>
<dd>The number of times to read from the pattern before stopping.
If None then the generator is unbounded. The default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The next item in the pattern.</p>
<h2 id="raises">Raises</h2>
<ul>
<li>TypeError: if items is not a list.</li>
<li>ValueError: if items is an empty list.</li>
<li>TypeError: if stop is not an int.</li>
<li>TypeError if weights is not a list.</li>
<li>ValueError if any weight is not a float or int.</li>
<li>IndexError if the number of items and weight are not the same.</li>
</ul>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; [choose([1,2,3]) for _ in range(8)]
[1,2,2,1,3,2,1,1]
</code></pre></div>
</dd>
<dt id="musx.generators.cycle"><code class="name flex">
<span>def <span class="ident">cycle</span></span>(<span>items, stop=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a generator that yields its items in a continuous cycle.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>items</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of values to generate.</dd>
<dt><strong><code>stop</code></strong> :&ensp;<code>int | None</code></dt>
<dd>The number of times to read from the pattern before stopping.
If None then the generator is unbounded. The default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The next item in the pattern.</p>
<h2 id="raises">Raises</h2>
<ul>
<li>TypeError: if items is not a list.</li>
<li>ValueError: if items is an empty list.</li>
<li>TypeError: if stop is not an int.</li>
</ul>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; [cycle([1,2,3]) for _ in range(5)]
[1, 2, 3, 1, 2]
</code></pre></div>
</dd>
<dt id="musx.generators.drunk"><code class="name flex">
<span>def <span class="ident">drunk</span></span>(<span>val, width=1, stop=None, filt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns numbers in a "drunken walk" where the next value returned is
constrained to lie within the bounds of the previous value plus/minus width.
If val and width are both integers then integer values are returned
otherwise floating point values are returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>val</code></strong> :&ensp;<code>int | float</code></dt>
<dd>The initial value returned by the walk. Thereafter drunk internally
updates this value according to width.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int | float</code></dt>
<dd>Constrains the next value returned to be within the bounds of the
current value plus/minus width.</dd>
<dt><strong><code>filt</code></strong> :&ensp;<code>None | function</code></dt>
<dd>If specified, filt is a function of one argument that will be
called with the current value to produce the value returned.</dd>
</dl></div>
</dd>
<dt id="musx.generators.getstate"><code class="name flex">
<span>def <span class="ident">getstate</span></span>(<span>cells, pos, inc)</span>
</code></dt>
<dd>
<div class="desc"><p>A helper function to call within a cellular automata's rule function to
access the value of neighbor cells at position pos + inc. See: <code><a title="musx.generators.states" href="#musx.generators.states">states()</a></code>.</p>
<p>The new position pos+inc will automatically wrap mod the size of the cells
array so will never go out of bounds.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cells</code></strong> :&ensp;<code>list</code></dt>
<dd>An array of cells holding the cellular automata's current states.</dd>
<dt><strong><code>pos</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The (<em>row</em>, <em>col</em>) index of the current cell in the cells array.
Your rule function will receive this position in its pos argument.
To access a neighbor cell, pass the pos value to getstate() along
with a positional increment <em>inc</em>.</dd>
<dt><strong><code>inc</code></strong> :&ensp;<code>int | tuple</code></dt>
<dd>A positive or negative offset to add to pos to calculate the position of the
neighbor cell. This must be a tuple (<em>row</em>, <em>col</em>) for 2D automata. For 1D
cases you can specify a positive or negative integer, or a tuple (0, <em>col</em>).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The value of the neighbor cell at pos+inc.</p></div>
</dd>
<dt id="musx.generators.jumble"><code class="name flex">
<span>def <span class="ident">jumble</span></span>(<span>items, stop=None, norep=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a generator that yields its items in random permutation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>items</code></strong> :&ensp;<code>list
</code></dt>
<dd>The list of values to generate.</dd>
<dt><strong><code>stop</code></strong> :&ensp;<code>int | None</code></dt>
<dd>The number of times to read from the pattern before stopping.
If None then the generator is unbounded. The default is None.</dd>
<dt><strong><code>norep</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true then items cannot repeat after a shuffle.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The next item in the pattern.</p>
<h2 id="raises">Raises</h2>
<ul>
<li>TypeError: if items is not a list.</li>
<li>ValueError: if items is an empty list.</li>
<li>TypeError: if stop is not an int.</li>
</ul>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; [jumble([1,2,3]) for _ in range(6)]
[1, 3, 2, 3, 2, 1] 
</code></pre></div>
</dd>
<dt id="musx.generators.markov"><code class="name flex">
<span>def <span class="ident">markov</span></span>(<span>rules, stop=None, preset=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a generator that yields items in a Markov chain. The chain is expressed
as a dictionary of rules, each rule associates a tuple of one or more past
outcomes with a list of weighted potential outcomes:</p>
<p><code>{(past,...): [[outcome, weight], [outcome, weight], ...],
...}</code></p>
<p>There are two shortcuts available when specifying rules:
* If the rules use only one past value (markov order 1) then you can provide
values as keys instead of tuples.
* If an outcome has a probability weight of 1 then you can specify just the
value instead of a two element list containing the value and 1.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rules</code></strong> :&ensp;<code>list</code></dt>
<dd>A dictionary of rules that generate the Markov chain. Each rule is a
key and value pair, where the key is a tuple of 1 or more past outcomes
and the value is a list of pairs [[outcome, weight1], [outcome2, weight2],&hellip;]
representing each possible next outcome together with its weight (probability).
The length of the tuples determines the markov order of the generator
and all rules must ha be the same and it .
The <next> columns in the rule contain the potential next outcomes
with their probability weights. Each column can contain just an outcome,
in which case it will be assigned a probability weight of 1, or it can
be expressed as a list [next, weight].</dd>
<dt><strong><code>stop</code></strong> :&ensp;<code>int | None</code></dt>
<dd>The number of times to read from the pattern before stopping.
If None then the generator is unbounded. The default is None.</dd>
<dt><strong><code>preset</code></strong> :&ensp;<code>past</code></dt>
<dd>If specified it is the initial 'past' the markov chain uses to generate
the first outcome.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The next item in the pattern.</p>
<h2 id="raises">Raises</h2>
<ul>
<li>TypeError if rules is not a list.</li>
<li>ValueError if rules is an empty list.</li>
<li>IndexError if all rule keys are not the same length (markov order).</li>
<li>ValueError if a rule's key is empty.</li>
<li>ValueError if a rule has no outcomes.</li>
<li>IndexError if a rule outcome is a list that is not length 2.</li>
<li>ValueError if a rule outcome is a list and the second element is not an int or float.</li>
<li>IndexError if preset is not the same length as markov order.</li>
<li>ValueError if a past does not match any rule.</li>
</ul>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; markov({'a': ['b', ['c', 3]], 
            'b': ['a'],
            'c': [['a', 5] 'c', [b, 2.5]]})
</code></pre>
<p>This is a 1st order markov process with three rules:</p>
<p>1) if the last outcome was 'a' then the next outcome is either 'b' or 'c',
with 'c' three times as likely as 'b'.
2) if the last outcome was 'b' then the next outcome is 'a'.
3) if the last outcome was 'c' then the next outcome is either 'a', 'c' or 'b',
with 'c' being the least likely and 'a' being the most likely outcome.</p></div>
</dd>
<dt id="musx.generators.markov_analyze"><code class="name flex">
<span>def <span class="ident">markov_analyze</span></span>(<span>seq, order)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the markov rules of the given order for the specified list of
data. The rules can be passed to <code><a title="musx.generators.markov" href="#musx.generators.markov">markov()</a></code> to generate a markov chain
based on the sequence analyzed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>seq</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of data to analyse.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code></dt>
<dd>The markov order of the analysis.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary containing the markov analysis of the data.</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; markov_analyze([2, 2, 1, 3, 4, 4, 1, 2], 1)
{(2,): [[2, 2], [1, 1]], (1,): [[3, 1], [2, 1]], (3,): [[4, 1]], (4,): [[4, 1], [1, 1]]}
</code></pre></div>
</dd>
<dt id="musx.generators.palindrome"><code class="name flex">
<span>def <span class="ident">palindrome</span></span>(<span>items, stop=None, wrap='++')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a generator that yields its items in a palindrome.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>items</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of values to generate.</dd>
<dt><strong><code>stop</code></strong> :&ensp;<code>int | None</code></dt>
<dd>The number of times to read from the pattern before stopping.
If None then the generator is unbounded. The default is None.</dd>
<dt><strong><code>wrap</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Determines if first and last elements are repeated when the pattern reverses.
For example if the items are [1, 2, 3] then wrap will produce:</p>
<ul>
<li>'++' : both first and last are repeated: 1,2,3,3,2,1,1,2,3 &hellip;</li>
<li>'+-' : Only the first is repeated: 1,2,3,2,1,1,2,3 &hellip;</li>
<li>'-+' : Only the last is repeated: 1,2,3,3,2,1,2,3 &hellip;</li>
<li>'&ndash;' : Neither is repeated: 1,2,3,2,1,2,3 &hellip;</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The next item in the pattern.</p>
<h2 id="raises">Raises</h2>
<ul>
<li>TypeError: if items is not a list.</li>
<li>ValueError: if items is an empty list.</li>
<li>TypeError: if stop is not an int.</li>
<li>ValueError if wrap is not one of the allowed values.</li>
</ul>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; [palindrome([1,2,3]) for _ in range(8)]
[1, 2, 3, 3, 2, 1, 1, 2]
</code></pre></div>
</dd>
<dt id="musx.generators.rotation"><code class="name flex">
<span>def <span class="ident">rotation</span></span>(<span>items, swaprules, stop=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Permutes the elements in items according to one or more "swapping rules".</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>items</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of items to generate</dd>
<dt><strong><code>swaprules</code></strong> :&ensp;<code>list | generator</code></dt>
<dd>The value can be on or more swapping rules or a generator that produces
swapping rules. A swapping rule is a list of (up to) four integers
that controls the iterative swapping that is applied to all the data
to produce the next generation of items:
<code>[start, step, width=1, end=len]</code>
Start is the location (zero based index) in the pattern's data to begin
swapping from, step is the rightward increment to move to the next swap
start, width is the distance between the elements swapped.
End is the
position in the item list to stop the swapping at, and defaults to the
length of the item list.</dd>
<dt><strong><code>stop</code></strong> :&ensp;<code>int | None</code></dt>
<dd>The number of times to read from the pattern before stopping.
If None then the generator is unbounded. The default is None.</dd>
</dl></div>
</dd>
<dt id="musx.generators.states"><code class="name flex">
<span>def <span class="ident">states</span></span>(<span>cells, stop=None, rule=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a generator that produces states from a cellular automata
that holds an array of initial states and a rule function that
updates the states to their next values. See: <code>getstates()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>states</code></strong> :&ensp;<code>list
</code></dt>
<dd>A list containing the initial states of the cellular automata. A
flat list of states produces a one dimensional automata and a row
major list of lists will create a two dimensional automata.</dd>
<dt><strong><code>stop</code></strong> :&ensp;<code>int | None</code></dt>
<dd>The number of times to read from the pattern before stopping.
If None then the generator is unbounded. The default is None.</dd>
<dt><strong><code>rule</code></strong> :&ensp;<code>function</code></dt>
<dd>The rule function implements the automata's state transition. The
function is called automatically and passed two arguments, the
states and the index of the current cell in the states. The function
can use <code><a title="musx.generators.getstate" href="#musx.generators.getstate">getstate()</a></code> to access one or more neighbor states in order
to calculate the next state of the current cell.
for more information.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The next item in the pattern.</p></div>
</dd>
<dt id="musx.generators.steps"><code class="name flex">
<span>def <span class="ident">steps</span></span>(<span>start, step, stop=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A generator that returns a value incremented by a stepping amount.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>int</code></dt>
<dd>The initial step value to generate.</dd>
<dt><strong><code>step</code></strong> :&ensp;<code>int</code></dt>
<dd>The amount to add to the step each time.</dd>
<dt><strong><code>stop</code></strong> :&ensp;<code>int | None</code></dt>
<dd>The number of values to read from the pattern. Defaults to max_int.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="musx" href="index.html">musx</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="musx.generators.allrotations" href="#musx.generators.allrotations">allrotations</a></code></li>
<li><code><a title="musx.generators.choose" href="#musx.generators.choose">choose</a></code></li>
<li><code><a title="musx.generators.cycle" href="#musx.generators.cycle">cycle</a></code></li>
<li><code><a title="musx.generators.drunk" href="#musx.generators.drunk">drunk</a></code></li>
<li><code><a title="musx.generators.getstate" href="#musx.generators.getstate">getstate</a></code></li>
<li><code><a title="musx.generators.jumble" href="#musx.generators.jumble">jumble</a></code></li>
<li><code><a title="musx.generators.markov" href="#musx.generators.markov">markov</a></code></li>
<li><code><a title="musx.generators.markov_analyze" href="#musx.generators.markov_analyze">markov_analyze</a></code></li>
<li><code><a title="musx.generators.palindrome" href="#musx.generators.palindrome">palindrome</a></code></li>
<li><code><a title="musx.generators.rotation" href="#musx.generators.rotation">rotation</a></code></li>
<li><code><a title="musx.generators.states" href="#musx.generators.states">states</a></code></li>
<li><code><a title="musx.generators.steps" href="#musx.generators.steps">steps</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>